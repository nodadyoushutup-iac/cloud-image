pipeline {
  agent any

  options {
    ansiColor('xterm')
    // Prevent parallel runs from sharing/holding onto the same workspace
    disableConcurrentBuilds()
    // Fail fast on stage errors (still runs post/cleanup)
    skipStagesAfterUnstable()
  }

  parameters {
    string(name: 'VERSION', description: 'Semantic version tag for the release')
    choice(name: 'FILE_NAME', choices: ['jammy-cloud-image-amd64'], description: 'Base file name')
    booleanParam(name: 'RETAIN_ARTIFACTS', defaultValue: false, description: 'If true, archive artifacts; otherwise everything is ephemeral and cleaned in post { always }.')
  }

  environment {
    PACKER_LOG = '1'
    // Expect CLOUD_IMAGE_REPOSITORY_URL to be provided via Jenkins credentials
    CLOUD_IMAGE_REPOSITORY_URL = credentials('CLOUD_IMAGE_REPOSITORY_URL')
  }

  stages {
    stage('Set build variables') {
      steps {
        script {
          env.FILE_NAME = "${params.FILE_NAME}-${params.VERSION}"
          // Ensure packer output stays inside the workspace for guaranteed cleanup
          env.OUTPUT_DIR = "${env.WORKSPACE}/output"
        }
      }
    }

    // stage('Clean output directory') {
    //   steps {
    //     sh '''
    //       set -euo
    //       rm -rf "${OUTPUT_DIR}"
    //     '''
    //   }
    // }

    stage('Show build variables') {
      steps {
        echo "Building version: ${params.VERSION}"
        echo "Final FILE_NAME: ${env.FILE_NAME}"
        echo "OUTPUT_DIR: ${env.OUTPUT_DIR}"
      }
    }

    // stage('Checkout') {
    //   steps {
    //     checkout scm
    //   }
    // }

    // stage('Packer init') {
    //   steps {
    //     sh 'packer init cloud_image.pkr.hcl'
    //   }
    // }

    // stage('Packer validate') {
    //   steps {
    //     sh 'packer validate cloud_image.pkr.hcl'
    //   }
    // }

    // stage('Packer build') {
    //   steps {
    //     sh '''
    //       set -euo
    //       mkdir -p "${OUTPUT_DIR}"
    //       packer build \
    //         -force \
    //         -var="output_dir=${OUTPUT_DIR}" \
    //         -var="file_name=${FILE_NAME}" \
    //         cloud_image.pkr.hcl
    //     '''
    //   }
    // }

    // stage('Generate checksum') {
    //   steps {
    //     sh '''
    //       set -euo
    //       mkdir -p "${OUTPUT_DIR}"
    //       sha256sum "${OUTPUT_DIR}/${FILE_NAME}.img" > "${OUTPUT_DIR}/${FILE_NAME}.img.sha256"
    //     '''
    //   }
    // }

    // stage('Upload image to cloud repository') {
    //   steps {
    //     withCredentials([string(credentialsId: 'CLOUD_IMAGE_REPOSITORY_APIKEY', variable: 'CLOUD_IMAGE_REPOSITORY_APIKEY')]) {
    //       sh '''
    //         set -euo
    //         response=$(./script/upload_image.sh "${OUTPUT_DIR}/${FILE_NAME}.img" "${CLOUD_IMAGE_REPOSITORY_URL}/upload")
    //         IMAGE_PATH=$(echo "$response" | jq -r '.path')
    //         SHA256_PATH=$(echo "$response" | jq -r '.sha256_file')
    //         IMAGE_SHA=$(echo "$response" | jq -r '.sha256')
    //         echo "Image URL: ${CLOUD_IMAGE_REPOSITORY_URL}/$IMAGE_PATH"
    //         echo "Checksum URL: ${CLOUD_IMAGE_REPOSITORY_URL}/$SHA256_PATH"
    //         echo "SHA256: $IMAGE_SHA"
    //       '''
    //     }
    //   }
    // }

    // stage('Archive artifacts (optional)') {
    //   when {
    //     expression { return params.RETAIN_ARTIFACTS }
    //   }
    //   steps {
    //     archiveArtifacts artifacts: "${OUTPUT_DIR}/${FILE_NAME}.img, ${OUTPUT_DIR}/${FILE_NAME}.img.sha256", fingerprint: true
    //   }
    // }
  }

  post {
    // Runs on success, failure, or when the build is aborted/cancelled
    always {
      echo 'Post-build cleanup starting (ephemeral workspace).'        
      script {
        // Best-effort cleanup of files created during the pipeline
        sh '''
          set +e
          # Remove generated outputs within the workspace
          rm -rf "${OUTPUT_DIR}" || true

          # Remove any common packer temp dirs within workspace
          find "${WORKSPACE}" -maxdepth 1 -type d -name "packer_*" -exec rm -rf {} + 2>/dev/null || true

          # Attempt to remove packer temp dirs under /tmp (best-effort)
          if command -v find >/dev/null 2>&1; then
            find /tmp -maxdepth 1 -type d -name "packer*" -mmin +10 -exec rm -rf {} + 2>/dev/null || true
          fi
        '''

        // Wipe the entire workspace to ensure nothing persists between builds
        deleteDir()
      }
      echo 'Post-build cleanup complete.'
    }

    failure {
      echo 'Build failed. Workspace has been cleaned.'
    }

    aborted {
      echo 'Build aborted. Workspace has been cleaned.'
    }
  }
}
