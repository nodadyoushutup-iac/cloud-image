#!/bin/bash
# --- USER SYNC (idempotent) ---

TARGET_USER="${SUDO_USER:-$USER}"
TARGET_HOME="$(eval echo "~$TARGET_USER")"
TARGET_GROUP="$(id -gn "$TARGET_USER")"

if [[ -z "$TARGET_GROUP" ]]; then
  echo "Unable to determine primary group for $TARGET_USER" >&2
  exit 1
fi

SRC_CODE="/mnt/eapp/code"
SRC_SSH="/mnt/eapp/skel/.ssh"
SRC_KUBE="/mnt/eapp/skel/.kube"
SRC_TFVARS="/mnt/eapp/skel/.tfvars"
SRC_JENKINS="/mnt/eapp/skel/.jenkins"
SRC_HOME="/mnt/eapp/skel/.home"
SRC_GITCONFIG="$SRC_HOME/.gitconfig"

FSTAB_FILE="/etc/fstab"
NFS_TYPE="nfs"
NFS_MOUNT_OPTIONS="defaults,_netdev"
NFS_DUMP=0
NFS_PASS=0
read -r -d '' FSTAB_HEADER <<'EOF'
# Managed by script/system/fstab.sh from the cloud-image repository.
# Do not edit this file manually; rerun the provisioning script instead.
EOF

declare -a NFS_ENTRIES=(
  "192.168.1.100:/mnt/epool/media /media"
  "192.168.1.100:/mnt/eapp/code $SRC_CODE"
  "192.168.1.100:/mnt/eapp/skel/.ssh $SRC_SSH"
  "192.168.1.100:/mnt/eapp/skel/.kube $SRC_KUBE"
  "192.168.1.100:/mnt/eapp/skel/.tfvars $SRC_TFVARS"
  "192.168.1.100:/mnt/eapp/skel/.home $SRC_HOME"
  "192.168.1.100:/mnt/eapp/skel/.jenkins $SRC_JENKINS"
)

ensure_fstab_entries() {
  if [[ ! -f "$FSTAB_FILE" ]]; then
    install -m 644 -o root -g root /dev/null "$FSTAB_FILE"
  fi

  printf '%s\n' "${NFS_ENTRIES[@]}" | python3 - \
    "$FSTAB_FILE" \
    "$FSTAB_HEADER" \
    "$NFS_TYPE" \
    "$NFS_MOUNT_OPTIONS" \
    "$NFS_DUMP" \
    "$NFS_PASS" <<'PY'
import pathlib
import sys

fstab_path = pathlib.Path(sys.argv[1])
header = sys.argv[2].strip()
fs_type = sys.argv[3]
options = sys.argv[4]
dump = sys.argv[5]
passno = sys.argv[6]

desired = {}
for raw in sys.stdin:
    raw = raw.strip()
    if not raw:
        continue
    src, dest = raw.split(None, 1)
    desired[dest] = f"{src} {dest} {fs_type} {options} {dump} {passno}"

if not desired:
    sys.exit(0)

if fstab_path.exists():
    lines = fstab_path.read_text().splitlines()
else:
    lines = []

changed = False
present = set()
header_present = any(line.strip() == header for line in lines)

for idx, line in enumerate(lines):
    stripped = line.strip()
    if not stripped or stripped.startswith('#'):
        continue
    parts = stripped.split()
    if len(parts) < 2:
        continue
    dest = parts[1]
    if dest not in desired:
        continue
    desired_line = desired[dest]
    if stripped != desired_line:
        lines[idx] = desired_line
        changed = True
    present.add(dest)

missing = [dest for dest in desired if dest not in present]

if missing:
    if not header_present:
        if lines and lines[-1].strip():
            lines.append('')
        lines.append(header)
        header_present = True
        changed = True
    for dest in missing:
        lines.append(desired[dest])
        changed = True

if changed:
    fstab_path.write_text('\n'.join(lines) + '\n')
PY
}

ensure_mountpoint() {
  local dir="$1"
  install -d -m 755 -o root -g root "$dir"
}

ensure_fstab_entries

SYSTEMD_AVAILABLE=0
if command -v systemctl >/dev/null 2>&1 && command -v systemd-escape >/dev/null 2>&1; then
  if systemctl daemon-reload >/dev/null 2>&1; then
    SYSTEMD_AVAILABLE=1
  else
    echo "Warning: systemctl daemon-reload failed; falling back to mount command" >&2
  fi
fi

systemd_mount_entry() {
  local dest="$1"
  (( SYSTEMD_AVAILABLE )) || return 1

  local unit
  if ! unit="$(systemd-escape -p --suffix=mount "$dest")"; then
    return 1
  fi

  if systemctl start "$unit" >/dev/null 2>&1; then
    return 0
  fi

  return 1
}

for entry in "${NFS_ENTRIES[@]}"; do
  read -r _ dest <<<"$entry"
  ensure_mountpoint "$dest"
done

for entry in "${NFS_ENTRIES[@]}"; do
  read -r src dest <<<"$entry"
  if mountpoint -q "$dest"; then
    continue
  fi
  if systemd_mount_entry "$dest"; then
    continue
  fi
  if mount -t "$NFS_TYPE" -o "$NFS_MOUNT_OPTIONS" "$src" "$dest"; then
    continue
  fi
  echo "Warning: failed to mount $src on $dest" >&2
done

# Ensure backing directories exist (avoids failing on first run)
ensure_src_dir() {
  local dir="$1" perm="$2"
  if [[ -e "$dir" && ! -d "$dir" ]]; then
    echo "Expected directory at $dir but found a file" >&2
    exit 1
  fi
  if [[ ! -d "$dir" ]]; then
    install -d -m "$perm" -o "$TARGET_USER" -g "$TARGET_GROUP" "$dir"
  fi
  chown "$TARGET_USER:$TARGET_GROUP" "$dir"
  chmod "$perm" "$dir"
}

ensure_src_dir "$SRC_CODE" 755
ensure_src_dir "$SRC_SSH" 700
ensure_src_dir "$SRC_KUBE" 755
ensure_src_dir "$SRC_TFVARS" 755
ensure_src_dir "$SRC_JENKINS" 755
ensure_src_dir "$SRC_HOME" 755

# Basic exists checks (also triggers automounts)
for p in "$SRC_CODE" "$SRC_SSH" "$SRC_KUBE" "$SRC_TFVARS" "$SRC_JENKINS" "$SRC_HOME"; do
  [[ -d "$p" ]] || { echo "Missing: $p"; exit 1; }
done

mkdir -p "$TARGET_HOME/.ssh"
chown "$TARGET_USER:$TARGET_USER" "$TARGET_HOME/.ssh"
chmod 700 "$TARGET_HOME/.ssh"

# Prefer rsync for a clean sync without xattrs/ACLs; fallback to cp
if command -v rsync >/dev/null 2>&1; then
  # -rlt: recurse, preserve symlinks/modtimes (not owner/group/perms)
  # --no-perms --no-owner --no-group to avoid "Operation not supported"
  rsync -rlt --no-perms --no-owner --no-group \
        "${SRC_SSH}/" "$TARGET_HOME/.ssh/"
else
  # cp fallback: overwrite files, don't preserve perms/owner/timestamps
  cp -rf --no-preserve=mode,ownership,timestamps "${SRC_SSH}/." "$TARGET_HOME/.ssh/"
fi

# Fix SSH ownership & perms (self-corrects each run)
chown -R "$TARGET_USER:$TARGET_USER" "$TARGET_HOME/.ssh"
# dirs 700
find "$TARGET_HOME/.ssh" -type d -exec chmod 700 {} +
# public/known_hosts 644; everything else 600
find "$TARGET_HOME/.ssh" -maxdepth 1 -type f -name "*.pub" -exec chmod 644 {} +
[[ -f "$TARGET_HOME/.ssh/known_hosts" ]] && chmod 644 "$TARGET_HOME/.ssh/known_hosts"
find "$TARGET_HOME/.ssh" -type f ! -name "*.pub" ! -name "known_hosts" -exec chmod 600 {} +

# Helper to make/repair symlink (backs up non-link targets)
ensure_symlink() {
  local src="$1" dest="$2"
  if [[ -L "$dest" ]]; then
    # already a symlink â€” check target
    if [[ "$(readlink -f "$dest")" == "$(readlink -f "$src")" ]]; then
      return 0
    else
      rm -f "$dest"
    fi
  elif [[ -e "$dest" ]]; then
    mv -T "$dest" "${dest}.bak.$(date +%F_%H-%M-%S)"
  fi
  ln -s -T "$src" "$dest"
}

# Create/repair symlinks in $HOME
ensure_symlink "$SRC_CODE"  "$TARGET_HOME/code"
ensure_symlink "$SRC_KUBE"  "$TARGET_HOME/.kube"
ensure_symlink "$SRC_TFVARS" "$TARGET_HOME/.tfvars"
ensure_symlink "$SRC_JENKINS" "$TARGET_HOME/.jenkins"
# Make sure the links themselves are owned by the user
chown -h "$TARGET_USER:$TARGET_USER" \
  "$TARGET_HOME/code" "$TARGET_HOME/.kube" "$TARGET_HOME/.tfvars" "$TARGET_HOME/.jenkins" || true

# Kubernetes likes strict perms on config
[[ -f "$TARGET_HOME/.kube/config" || -L "$TARGET_HOME/.kube/config" ]] && chmod 600 "$TARGET_HOME/.kube/config" || true

# Install/repair .gitconfig (back up if content differs)
if [[ -f "$SRC_GITCONFIG" ]]; then
  DEST_GIT="$TARGET_HOME/.gitconfig"
  if [[ -f "$DEST_GIT" ]] && ! cmp -s "$SRC_GITCONFIG" "$DEST_GIT"; then
    mv -T "$DEST_GIT" "${DEST_GIT}.bak.$(date +%F_%H-%M-%S)"
  fi
  install -m 600 -o "$TARGET_USER" -g "$TARGET_USER" "$SRC_GITCONFIG" "$DEST_GIT"
fi

echo "User sync complete for $TARGET_USER"
