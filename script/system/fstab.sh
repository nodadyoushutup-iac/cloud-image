#!/bin/bash
# --- USER SYNC (idempotent) ---

TARGET_USER="${SUDO_USER:-$USER}"
TARGET_HOME="$(eval echo "~$TARGET_USER")"
TARGET_GROUP="$(id -gn "$TARGET_USER")"

if [[ -z "$TARGET_GROUP" ]]; then
  echo "Unable to determine primary group for $TARGET_USER" >&2
  exit 1
fi

SRC_CODE="/mnt/eapp/code"
SRC_SSH="/mnt/eapp/skel/.ssh"
SRC_KUBE="/mnt/eapp/skel/.kube"
SRC_TFVARS="/mnt/eapp/skel/.tfvars"
SRC_JENKINS="/mnt/eapp/skel/.jenkins"
SRC_HOME="/mnt/eapp/skel/.home"
SRC_GITCONFIG="$SRC_HOME/.gitconfig"

FSTAB_FILE="/etc/fstab"

FSTAB_D_DIR="/etc/fstab.d"
FSTAB_DROPIN="$FSTAB_D_DIR/99-eapp-nfs.conf"
NFS_TYPE="nfs"
NFS_MOUNT_OPTIONS="defaults,_netdev"
NFS_DUMP=0
NFS_PASS=0
read -r -d '' FSTAB_HEADER <<'EOF'
# Managed by script/system/fstab.sh from the cloud-image repository.
# Do not edit this file manually; rerun the provisioning script instead.
EOF

declare -a NFS_ENTRIES=(
  "192.168.1.100:/mnt/epool/media /media"
  "192.168.1.100:/mnt/eapp/code $SRC_CODE"
  "192.168.1.100:/mnt/eapp/skel/.ssh $SRC_SSH"
  "192.168.1.100:/mnt/eapp/skel/.kube $SRC_KUBE"
  "192.168.1.100:/mnt/eapp/skel/.tfvars $SRC_TFVARS"
  "192.168.1.100:/mnt/eapp/skel/.home $SRC_HOME"
  "192.168.1.100:/mnt/eapp/skel/.jenkins $SRC_JENKINS"
)

ensure_fstab_dropin() {
  install -d -m 755 -o root -g root "$FSTAB_D_DIR"

  local tmp
  tmp="$(mktemp)"
  {
    echo "$FSTAB_HEADER"
    for entry in "${NFS_ENTRIES[@]}"; do
      read -r src dest <<<"$entry"
      printf '%s %s %s %s %s %s\n' \
        "$src" "$dest" "$NFS_TYPE" "$NFS_MOUNT_OPTIONS" "$NFS_DUMP" "$NFS_PASS"
    done
  } >"$tmp"

  if [[ ! -f "$FSTAB_DROPIN" ]] || ! cmp -s "$tmp" "$FSTAB_DROPIN"; then
    install -m 644 -o root -g root "$tmp" "$FSTAB_DROPIN"
  fi
  rm -f "$tmp"
}

ensure_mount_extra_directive() {
  local directive="x-systemd.mount-extra=$FSTAB_D_DIR"

  if [[ ! -f "$FSTAB_FILE" ]]; then
    echo "Warning: missing $FSTAB_FILE; cannot configure mount-extra directive" >&2
    return 1
  fi

  if grep -q "${directive//\//\/}" "$FSTAB_FILE"; then
    return 0
  fi

  python3 - "$FSTAB_FILE" "$directive" <<'PY'
import pathlib
import sys

fstab_path = pathlib.Path(sys.argv[1])
directive = sys.argv[2]
lines = fstab_path.read_text().splitlines()
changed = False
found_root = False

for idx, line in enumerate(lines):
    stripped = line.strip()
    if not stripped or stripped.startswith('#'):
        continue

    parts = stripped.split()
    if len(parts) < 4:
        continue

    if parts[1] != '/':
        continue

    found_root = True
    options = parts[3]

    if directive in options.split(','):
        break

    if options in ('', '-'):
        new_options = directive
    else:
        new_options = options.rstrip(',') + ',' + directive

    prefix, suffix = line.split(options, 1)
    lines[idx] = prefix + new_options + suffix
    changed = True
    break

if changed:
    fstab_path.write_text('\n'.join(lines) + '\n')
elif not found_root:
    sys.stderr.write('Warning: unable to locate root (/) entry in %s to set %s\n' % (fstab_path, directive))
PY
}

ensure_mountpoint() {
  local dir="$1"
  install -d -m 755 -o root -g root "$dir"
}

ensure_fstab_dropin
ensure_mount_extra_directive

SYSTEMD_AVAILABLE=0
if command -v systemctl >/dev/null 2>&1 && command -v systemd-escape >/dev/null 2>&1; then
  if systemctl daemon-reload >/dev/null 2>&1; then
    SYSTEMD_AVAILABLE=1
  else
    echo "Warning: systemctl daemon-reload failed; falling back to mount command" >&2
  fi
fi

systemd_mount_entry() {
  local dest="$1"
  (( SYSTEMD_AVAILABLE )) || return 1

  local unit
  if ! unit="$(systemd-escape -p --suffix=mount "$dest")"; then
    return 1
  fi

  if systemctl start "$unit" >/dev/null 2>&1; then
    return 0
  fi

  return 1
}

for entry in "${NFS_ENTRIES[@]}"; do
  read -r _ dest <<<"$entry"
  ensure_mountpoint "$dest"
done

for entry in "${NFS_ENTRIES[@]}"; do
  read -r src dest <<<"$entry"
  if mountpoint -q "$dest"; then
    continue
  fi
  if systemd_mount_entry "$dest"; then
    continue
  fi
  if mount -t "$NFS_TYPE" -o "$NFS_MOUNT_OPTIONS" "$src" "$dest"; then
    continue
  fi
  echo "Warning: failed to mount $src on $dest" >&2
done

# Ensure backing directories exist (avoids failing on first run)
ensure_src_dir() {
  local dir="$1" perm="$2"
  if [[ -e "$dir" && ! -d "$dir" ]]; then
    echo "Expected directory at $dir but found a file" >&2
    exit 1
  fi
  if [[ ! -d "$dir" ]]; then
    install -d -m "$perm" -o "$TARGET_USER" -g "$TARGET_GROUP" "$dir"
  fi
  chown "$TARGET_USER:$TARGET_GROUP" "$dir"
  chmod "$perm" "$dir"
}

ensure_src_dir "$SRC_CODE" 755
ensure_src_dir "$SRC_SSH" 700
ensure_src_dir "$SRC_KUBE" 755
ensure_src_dir "$SRC_TFVARS" 755
ensure_src_dir "$SRC_JENKINS" 755
ensure_src_dir "$SRC_HOME" 755

# Basic exists checks (also triggers automounts)
for p in "$SRC_CODE" "$SRC_SSH" "$SRC_KUBE" "$SRC_TFVARS" "$SRC_JENKINS" "$SRC_HOME"; do
  [[ -d "$p" ]] || { echo "Missing: $p"; exit 1; }
done

mkdir -p "$TARGET_HOME/.ssh"
chown "$TARGET_USER:$TARGET_USER" "$TARGET_HOME/.ssh"
chmod 700 "$TARGET_HOME/.ssh"

# Prefer rsync for a clean sync without xattrs/ACLs; fallback to cp
if command -v rsync >/dev/null 2>&1; then
  # -rlt: recurse, preserve symlinks/modtimes (not owner/group/perms)
  # --no-perms --no-owner --no-group to avoid "Operation not supported"
  rsync -rlt --no-perms --no-owner --no-group \
        "${SRC_SSH}/" "$TARGET_HOME/.ssh/"
else
  # cp fallback: overwrite files, don't preserve perms/owner/timestamps
  cp -rf --no-preserve=mode,ownership,timestamps "${SRC_SSH}/." "$TARGET_HOME/.ssh/"
fi

# Fix SSH ownership & perms (self-corrects each run)
chown -R "$TARGET_USER:$TARGET_USER" "$TARGET_HOME/.ssh"
# dirs 700
find "$TARGET_HOME/.ssh" -type d -exec chmod 700 {} +
# public/known_hosts 644; everything else 600
find "$TARGET_HOME/.ssh" -maxdepth 1 -type f -name "*.pub" -exec chmod 644 {} +
[[ -f "$TARGET_HOME/.ssh/known_hosts" ]] && chmod 644 "$TARGET_HOME/.ssh/known_hosts"
find "$TARGET_HOME/.ssh" -type f ! -name "*.pub" ! -name "known_hosts" -exec chmod 600 {} +

# Helper to make/repair symlink (backs up non-link targets)
ensure_symlink() {
  local src="$1" dest="$2"
  if [[ -L "$dest" ]]; then
    # already a symlink â€” check target
    if [[ "$(readlink -f "$dest")" == "$(readlink -f "$src")" ]]; then
      return 0
    else
      rm -f "$dest"
    fi
  elif [[ -e "$dest" ]]; then
    mv -T "$dest" "${dest}.bak.$(date +%F_%H-%M-%S)"
  fi
  ln -s -T "$src" "$dest"
}

# Create/repair symlinks in $HOME
ensure_symlink "$SRC_CODE"  "$TARGET_HOME/code"
ensure_symlink "$SRC_KUBE"  "$TARGET_HOME/.kube"
ensure_symlink "$SRC_TFVARS" "$TARGET_HOME/.tfvars"
ensure_symlink "$SRC_JENKINS" "$TARGET_HOME/.jenkins"
# Make sure the links themselves are owned by the user
chown -h "$TARGET_USER:$TARGET_USER" \
  "$TARGET_HOME/code" "$TARGET_HOME/.kube" "$TARGET_HOME/.tfvars" "$TARGET_HOME/.jenkins" || true

# Kubernetes likes strict perms on config
[[ -f "$TARGET_HOME/.kube/config" || -L "$TARGET_HOME/.kube/config" ]] && chmod 600 "$TARGET_HOME/.kube/config" || true

# Install/repair .gitconfig (back up if content differs)
if [[ -f "$SRC_GITCONFIG" ]]; then
  DEST_GIT="$TARGET_HOME/.gitconfig"
  if [[ -f "$DEST_GIT" ]] && ! cmp -s "$SRC_GITCONFIG" "$DEST_GIT"; then
    mv -T "$DEST_GIT" "${DEST_GIT}.bak.$(date +%F_%H-%M-%S)"
  fi
  install -m 600 -o "$TARGET_USER" -g "$TARGET_USER" "$SRC_GITCONFIG" "$DEST_GIT"
fi

echo "User sync complete for $TARGET_USER"
